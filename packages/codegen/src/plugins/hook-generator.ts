import type { AbiFunctionItem, AbiParameter, CodegenPlugin, ContractArtifact, GeneratedFile } from '../types.js'

const DO_NOT_EDIT_HEADER = `// ============================================================
// THIS FILE IS AUTO-GENERATED BY @web3market/codegen
// DO NOT EDIT THIS FILE MANUALLY
// ============================================================
`

function solidityTypeToTs(solidityType: string): string {
  if (solidityType.endsWith('[]')) return `readonly ${solidityTypeToTs(solidityType.slice(0, -2))}[]`
  const fixedArrayMatch = solidityType.match(/^(.+)\[(\d+)\]$/)
  if (fixedArrayMatch) return `readonly ${solidityTypeToTs(fixedArrayMatch[1]!)}[]`
  if (solidityType === 'address') return '`0x${string}`'
  if (solidityType === 'bool') return 'boolean'
  if (solidityType === 'string') return 'string'
  if (solidityType === 'bytes' || /^bytes\d+$/.test(solidityType)) return '`0x${string}`'
  if (/^u?int\d*$/.test(solidityType)) return 'bigint'
  if (solidityType === 'tuple') return 'unknown'
  return 'unknown'
}

function tupleTypeToTs(param: AbiParameter): string {
  if (param.type === 'tuple' && param.components && param.components.length > 0) {
    const fields = param.components
      .map((comp) => {
        const fieldType = comp.type === 'tuple' ? tupleTypeToTs(comp) : solidityTypeToTs(comp.type)
        return `    ${comp.name || '_'}: ${fieldType}`
      })
      .join('\n')
    return `{\n${fields}\n  }`
  }
  if (param.type.startsWith('tuple') && param.type.endsWith('[]')) {
    return `readonly ${tupleTypeToTs({ ...param, type: 'tuple' })}[]`
  }
  return solidityTypeToTs(param.type)
}

function paramTypeToTs(param: AbiParameter): string {
  if (param.type === 'tuple' || param.type.startsWith('tuple[')) return tupleTypeToTs(param)
  return solidityTypeToTs(param.type)
}

function safeParamName(param: AbiParameter, index: number): string {
  if (param.name && param.name.length > 0) {
    const reserved = new Set([
      'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger',
      'default', 'delete', 'do', 'else', 'enum', 'export', 'extends',
      'false', 'finally', 'for', 'function', 'if', 'import', 'in',
      'instanceof', 'new', 'null', 'return', 'super', 'switch', 'this',
      'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with',
    ])
    if (reserved.has(param.name)) return `_${param.name}`
    return param.name
  }
  return `arg${index}`
}

function capitalize(s: string): string {
  return s.length === 0 ? s : s.charAt(0).toUpperCase() + s.slice(1)
}

function extractFunctions(abi: readonly unknown[]): AbiFunctionItem[] {
  return abi.filter(
    (item): item is AbiFunctionItem =>
      typeof item === 'object' && item !== null && 'type' in item &&
      (item as Record<string, unknown>).type === 'function',
  )
}

function categorizeFunctions(functions: AbiFunctionItem[]) {
  return {
    reads: functions.filter((fn) => fn.stateMutability === 'view' || fn.stateMutability === 'pure'),
    writes: functions.filter((fn) => fn.stateMutability === 'nonpayable' || fn.stateMutability === 'payable'),
  }
}

function generateArgsType(inputs: readonly AbiParameter[]): string {
  if (inputs.length === 0) return ''
  const fields = inputs.map((param, i) => `  ${safeParamName(param, i)}: ${paramTypeToTs(param)}`).join('\n')
  return `{\n${fields}\n}`
}

function generateReadHook(contractName: string, fn: AbiFunctionItem): string {
  const hookName = `useRead${contractName}${capitalize(fn.name)}`
  const hasArgs = fn.inputs.length > 0
  const argsTypeName = hasArgs ? `${capitalize(fn.name)}Args` : null
  const argsTypeDecl = hasArgs ? `interface ${argsTypeName} ${generateArgsType(fn.inputs)}\n\n` : ''
  const argsParam = hasArgs ? `args: ${argsTypeName}` : ''
  const argsArray = hasArgs ? `[${fn.inputs.map((p, i) => `args.${safeParamName(p, i)}`).join(', ')}]` : '[]'
  const abiVarName = `${contractName.charAt(0).toLowerCase() + contractName.slice(1)}Abi`

  return `${argsTypeDecl}export function ${hookName}(${argsParam ? `${argsParam}, options?: { address: \`0x\${string}\`; enabled?: boolean }` : `options: { address: \`0x\${string}\`; enabled?: boolean }`}) {
  return useReadContract({
    address: options.address,
    abi: ${abiVarName},
    functionName: '${fn.name}',
    args: ${argsArray},
    query: { enabled: options?.enabled },
  })
}`
}

function generateWriteHook(contractName: string, fn: AbiFunctionItem): string {
  const hookName = `useWrite${contractName}${capitalize(fn.name)}`
  const hasArgs = fn.inputs.length > 0
  const argsTypeName = hasArgs ? `${capitalize(fn.name)}WriteArgs` : null
  const argsTypeDecl = hasArgs ? `interface ${argsTypeName} ${generateArgsType(fn.inputs)}\n\n` : ''
  const argsParam = hasArgs ? `args: ${argsTypeName}` : ''
  const argsArray = hasArgs ? `[${fn.inputs.map((p, i) => `args.${safeParamName(p, i)}`).join(', ')}]` : '[]'
  const abiVarName = `${contractName.charAt(0).toLowerCase() + contractName.slice(1)}Abi`

  return `${argsTypeDecl}export function ${hookName}(${argsParam ? `address: \`0x\${string}\`, ${argsParam}` : `address: \`0x\${string}\``}) {
  const { writeContract, ...rest } = useWriteContract()
  return {
    ...rest,
    write: () => writeContract({
      address,
      abi: ${abiVarName},
      functionName: '${fn.name}',
      args: ${argsArray},
    }),
  }
}`
}

function generateHooksFile(artifact: ContractArtifact): GeneratedFile | null {
  const functions = extractFunctions(artifact.abi)
  if (functions.length === 0) return null
  const { reads, writes } = categorizeFunctions(functions)
  if (reads.length === 0 && writes.length === 0) return null

  const contractName = artifact.name
  const abiVarName = `${contractName.charAt(0).toLowerCase() + contractName.slice(1)}Abi`
  const imports: string[] = []
  if (reads.length > 0) imports.push('useReadContract')
  if (writes.length > 0) imports.push('useWriteContract')

  const lines: string[] = [
    DO_NOT_EDIT_HEADER,
    `import { ${imports.join(', ')} } from 'wagmi'`,
    `import { ${abiVarName} } from '../abis/${contractName}.js'`,
    '',
  ]

  if (reads.length > 0) {
    lines.push('// ---- Read Hooks ----', '')
    for (const fn of reads) { lines.push(generateReadHook(contractName, fn), '') }
  }
  if (writes.length > 0) {
    lines.push('// ---- Write Hooks ----', '')
    for (const fn of writes) { lines.push(generateWriteHook(contractName, fn), '') }
  }

  return { path: `hooks/use${contractName}.ts`, content: lines.join('\n') }
}

export const hookGeneratorPlugin: CodegenPlugin = {
  name: 'hook-generator',
  async generate(artifacts: ContractArtifact[]): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = []
    for (const artifact of artifacts) {
      const file = generateHooksFile(artifact)
      if (file) files.push(file)
    }
    return files
  },
}

export { solidityTypeToTs, extractFunctions, categorizeFunctions, generateHooksFile, capitalize }
