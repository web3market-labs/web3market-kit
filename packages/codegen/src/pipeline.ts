import * as fs from 'node:fs/promises'
import * as path from 'node:path'
import type { CodegenPlugin, ContractArtifact, GeneratedFile, ResolveConfig } from './types.js'
import { foundryResolverPlugin } from './plugins/foundry-resolver.js'
import { hookGeneratorPlugin } from './plugins/hook-generator.js'
import { abiGeneratorPlugin } from './plugins/abi-generator.js'
import { createAddressGeneratorPlugin } from './plugins/address-generator.js'

export interface KitConfig {
  root: string
  contracts?: {
    root?: string
    framework?: 'foundry' | 'hardhat'
    include?: string[]
    exclude?: string[]
  }
  codegen?: {
    outDir?: string
    plugins?: CodegenPlugin[]
  }
}

export interface CodegenOptions {
  deploymentsDir?: string
}

function generateBarrelFile(files: GeneratedFile[]): GeneratedFile {
  const exports = files
    .filter((f) => f.path.endsWith('.ts') && f.path !== 'index.ts')
    .map((f) => `export * from './${f.path.replace(/\.ts$/, '.js')}'`)
    .sort()
  return {
    path: 'index.ts',
    content: [
      '// ============================================================',
      '// THIS FILE IS AUTO-GENERATED BY @web3marketlabs/codegen',
      '// DO NOT EDIT THIS FILE MANUALLY',
      '// ============================================================',
      '', ...exports, '',
    ].join('\n'),
  }
}

export async function runCodegen(config: KitConfig, options?: CodegenOptions): Promise<void> {
  const root = config.root
  const contractsRoot = config.contracts?.root ?? root
  const framework = config.contracts?.framework ?? 'foundry'
  const include = config.contracts?.include ?? []
  const exclude = config.contracts?.exclude ?? []
  const outDir = path.resolve(root, config.codegen?.outDir ?? 'generated')

  const resolveConfig: ResolveConfig = { root: contractsRoot, include, exclude, framework }

  const deploymentsDir = options?.deploymentsDir ?? path.join(root, 'deployments')
  const defaultPlugins: CodegenPlugin[] = [
    foundryResolverPlugin, abiGeneratorPlugin, hookGeneratorPlugin,
    createAddressGeneratorPlugin(deploymentsDir),
  ]
  const plugins = config.codegen?.plugins ?? defaultPlugins

  console.log('[codegen] Stage 1: Resolving contract artifacts...')
  let artifacts: ContractArtifact[] = []
  for (const plugin of plugins.filter((p) => p.resolve != null)) {
    const resolved = await plugin.resolve!(resolveConfig)
    artifacts = artifacts.concat(resolved)
    console.log(`[codegen]   ${plugin.name}: found ${resolved.length} artifacts`)
  }

  if (artifacts.length === 0) {
    console.log('[codegen] No contract artifacts found. Skipping generation.')
    return
  }

  console.log('[codegen] Stage 2: Parsing ABI data...')
  const seen = new Set<string>()
  const uniqueArtifacts: ContractArtifact[] = []
  for (const artifact of artifacts) {
    if (!seen.has(artifact.name)) { seen.add(artifact.name); uniqueArtifacts.push(artifact) }
  }

  console.log('[codegen] Stage 3: Generating output files...')
  let allFiles: GeneratedFile[] = []
  for (const plugin of plugins.filter((p) => p.generate != null)) {
    const files = await plugin.generate!(uniqueArtifacts)
    allFiles = allFiles.concat(files)
    console.log(`[codegen]   ${plugin.name}: generated ${files.length} files`)
  }

  for (const plugin of plugins.filter((p) => p.validate != null)) {
    const result = await plugin.validate!(allFiles)
    if (!result.valid) {
      throw new Error(`[codegen] Validation failed in ${plugin.name}:\n${result.errors.map((e) => `  - ${e}`).join('\n')}`)
    }
  }

  allFiles.push(generateBarrelFile(allFiles))

  console.log(`[codegen] Stage 4: Writing ${allFiles.length} files to ${outDir}...`)
  const dirs = new Set<string>()
  for (const file of allFiles) dirs.add(path.dirname(path.join(outDir, file.path)))
  for (const dir of dirs) await fs.mkdir(dir, { recursive: true })
  for (const file of allFiles) await fs.writeFile(path.join(outDir, file.path), file.content, 'utf-8')

  console.log('[codegen] Done.')
}
